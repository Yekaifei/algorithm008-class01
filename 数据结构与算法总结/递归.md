## 递归

### 递归需要满足的三个条件

刚刚这个例子是非常典型的递归，那究竟什么样的问题可以用递归来解决呢？总结了三个条件，只要同时满足以下三个条件，就可以用递归来解决。

**1. 一个问题的解可以分解为几个子问题的解**

何为子问题？子问题就是数据规模更小的问题。

**2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样**

**3. 存在递归终止条件**

把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。

**写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码**。

**编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤**。

### 递归代码咬警惕堆栈溢出

* 我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。

```java
// 全局变量，表示递归的深度。
int depth = 0;
 
int f(int n) {
  ++depth；
  if (depth > 1000) throw exception;
  
  if (n == 1) return 1;
  return f(n-1) + 1;
}
```

* 递归代码咬警惕重复计算

为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。

