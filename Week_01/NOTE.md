# Array，LinkedList，SkipList

## Array 时间复杂度

- Prepend, Append：O(1)
- Insert, Delete：O(n)
- Lookup：O(1)

## 链表的时间复杂度

- Prepend, Append：O(1)
- Lookup：O(n)
- Insert, Delete：O(1)

## 跳表：SkipList

跳表是基于链表的数据结构优化之后的一种数据结构。

### 跳表是如何对链表进行优化的

在链表的基础上，跳表增加了多级索引，查找元素时，从最顶层索引一直向下找，直到查找到该元素。

[![Skip List](https://github.com/ryan4cloud/algorithm008-class01/raw/master/Week_01/skiplist1.png)](https://github.com/ryan4cloud/algorithm008-class01/blob/master/Week_01/skiplist1.png)

### 跳表时间复杂度分析

第一级索引的个数为 n/2，第二级索引的个数为 n/4，由此类推，第 k 级索引的格式就是 n/(2^k)。假设索引有 h 级，最高级的索引有 2 个结点。n/(2^h) = 2，从而求得 h = log2(n)-1。

以上可得知，索引的高度为 logn，每层最多遍历的节点个数为 3。所以在跳表中查询任意数据的时间复杂度就是 O(logn)。

### 跳表空间复杂度分析

原始链表大小为 n，每 2 个结点抽 1 个，每层索引的结点数： $$ \frac{n}{2}, \frac{n}{4}, \frac{n}{8}, ... ,8, 4, 2 $$ 原始链表大小为 n，每 3 个节点抽 1 个，每层索引的节点数： $$ \frac{n}{3}, \frac{n}{9}, \frac{n}{27}, ... , 9, 3, 1 $$ 每层索引的个数相加，无线接近于 n。所以空间复杂度是 O(n)。

## 总结

- 熟悉数组，链表，跳表是如何实现的
- 牢记三者的时间复杂度，空间复杂度
- 工程中的应用：LRU Cache(Linked List)，Redis(Skip List)
- 跳表：升维思想，用空间来换时间

## 算法练习总结 

注： 这是他人写的，看见了觉得总结的很到位，mark一下就不重复献丑了。

本周的算法题主要集中在数组，链表，以及栈和队列相关的题目，下面总结一下这周训练过程中获得的解题技巧，

### 技巧1：定义多个指针协助解题

141-环形链表，206-反转链表等题目实际上都可以通过引入多个指针，然后通过指针的移动控制元素的变化， 来达到解题目的，还有一些应用快慢指针的思路，个人觉得遇到链表的一些题目，大多都需要定义多个临时的 指针变量，来辅助各个节点在循环中的变化。

### 技巧2：干想不如画图

基本上每个算法题目，我都会在演算纸上面把每次循环后元素的变化画在纸上，来辅助自己理清楚思路，即使 有些题目并不是自己想出来的解法，也会把别人的解法理解了之后再自己思考一遍，这样基本上图画清楚之后， 写代码也就是水到渠成的事情了，尤其是链表相关的题目，由于代码理解起来比较晦涩，并不直观，所以必须 要把指针的变化画在纸上。

### 技巧3：找到子问题，巧用递归

其实链表的很多题目都可以通过递归的方式来解决，而递归的重点就在于如何找到子问题，比如爬楼梯问题中， 递归的方法就在于只关心最后1级台阶和最后两级台阶的走法，来假设子问题已经解决，那么只解决最后一步 就可以了，同理也适用于反转链表，假设head节点之后的所有节点都已经被正确反转了，那么就只需要考虑 如何反转head节点和已经反转之后的那个返回值节点之间如何反转就可以了。

### 技巧4：理解题意，关注边界

我认为很多算法题目其实解法并不难，难的在于深入的利用题目所给出的限定条件，这时就需要深刻理解题目， 就像老师课程中讲的，面试时要和面试官反复确认题目要求，确保理解题意；而另外一个重点就是关注各种边界 条件的处理，因为往往逻辑虽然是正确的，但也会由于边界条件没有仔细考虑，而导致某些corner case无法 通过。

